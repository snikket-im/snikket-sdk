/* tslint:disable */// Generated by Haxe TypeScript Declaration Generator :)

import { borogove_UiState, borogove_calls_CallStatus, borogove_MessageDirection, borogove_EncryptionStatus, borogove_MessageStatus, borogove_MessageType, borogove_UserState, borogove_ChatMessageEvent, borogove_ReactionUpdateKind } from "./borogove-browser-enums";

export class borogove_Caps {
	constructor(node: string, identities: borogove_Identity[], features: string[], data: borogove_Stanza[], ver?: ArrayBuffer | null);
	node: string;
	identities: borogove_Identity[];
	features: string[];
	data: borogove_Stanza[];
	isChannel(chatId: string): boolean;
	discoReply(): borogove_Stanza;
	addC(stanza: borogove_Stanza): borogove_Stanza;
	verRaw(): borogove_Hash;
	ver(): string;
}

export class haxe_io_Bytes {
	protected constructor(data: ArrayBuffer);
	readonly length: number;
	/**
	 * Copies `len` bytes from `src` into this instance.
	 * @param pos Zero-based location in `this` instance at which to start writing
	 * bytes.
	 * @param src Source `Bytes` instance from which to copy bytes.
	 * @param srcpos Zero-based location at `src` from which bytes will be copied.
	 * @param len Number of bytes to be copied.
	 */
	blit(pos: number, src: haxe_io_Bytes, srcpos: number, len: number): void;
	/**
	 * Sets `len` consecutive bytes starting from index `pos` of `this` instance
	 * to `value`.
	 */
	fill(pos: number, len: number, value: number): void;
	/**
	 * Returns a new `Bytes` instance that contains a copy of `len` bytes of
	 * `this` instance, starting at index `pos`.
	 */
	sub(pos: number, len: number): haxe_io_Bytes;
	/**
	 * Returns the 16-bit unsigned integer at the given position `pos` (in
	 * little-endian encoding).
	 */
	getUInt16(pos: number): number;
	/**
	 * Returns the `len`-bytes long string stored at the given position `pos`,
	 * interpreted with the given `encoding` (UTF-8 by default).
	 */
	getString(pos: number, len: number, encoding?: any | null): string;
	/**
	 * Returns a `String` representation of the bytes interpreted as UTF-8.
	 */
	toString(): string;
	/**
	 * Returns a hexadecimal `String` representation of the bytes of `this`
	 * instance.
	 */
	toHex(): string;
	/**
	 * Returns the `Bytes` representation of the given `String`, using the
	 * specified encoding (UTF-8 by default).
	 */
	static ofString(s: string, encoding?: any | null): haxe_io_Bytes;
	/**
	 * Returns the `Bytes` representation of the given `BytesData`.
	 */
	static ofData(b: ArrayBuffer): haxe_io_Bytes;
	/**
	 * Converts the given hexadecimal `String` to `Bytes`. `s` must be a string of
	 * even length consisting only of hexadecimal digits. For example:
	 * `"0FDA14058916052309"`.
	 */
	static ofHex(s: string): haxe_io_Bytes;
}

/**
 * An Output is an abstract write. A specific output implementation will only
 * have to override the `writeByte` and maybe the `write`, `flush` and `close`
 * methods. See `File.write` and `String.write` for two ways of creating an
 * Output.
 */
export class haxe_io_Output {
	protected constructor();
	/**
	 * Write one byte.
	 */
	writeByte(c: number): void;
	/**
	 * Write `len` bytes from `s` starting by position specified by `pos`.
	 * Returns the actual length of written data that can differ from `len`.
	 * See `writeFullBytes` that tries to write the exact amount of specified bytes.
	 */
	writeBytes(s: haxe_io_Bytes, pos: number, len: number): number;
	/**
	 * Close the output.
	 * Behaviour while writing after calling this method is unspecified.
	 */
	close(): void;
}

export class borogove_Identity {
	constructor(category: string, type: string, name: string, lang?: string | null);
	category: string;
	type: string;
	name: string;
	lang: string;
	addToDisco(stanza: borogove_Stanza): void;
	ver(): string;
	writeTo(out: haxe_io_Output): void;
}

export class borogove_GenericStream extends borogove_EventEmitter {
	constructor();
	_hx_constructor(): void;
	clientId: string | null;
	readonly csi: boolean;
	emitSMupdates: boolean;
	register(domain: string, preAuth: string | null): Promise<borogove_Stanza>;
	connect(jid: string, sm: ArrayBuffer | null): void;
	disconnect(): void;
	sendStanza(stanza: borogove_Stanza): void;
	newId(): string;
	onIq(type: any, tag: string, xmlns: string, handler: (arg0: borogove_Stanza) => any): void;
	sendIq(stanza: borogove_Stanza, callback: (stanza: borogove_Stanza) => void): void;
}

export class borogove_Chat {
	protected constructor(client: borogove_Client, stream: borogove_GenericStream, persistence: borogove_Persistence, chatId: string, uiState?: borogove_UiState, isBookmarked?: boolean, isBlocked?: boolean, extensions?: borogove_Stanza | null, readUpToId?: string | null, readUpToBy?: string | null, omemoContactDeviceIDs?: number[] | null);
	/**
	 * ID of this Chat
	 */
	readonly chatId: string;
	/**
	 * Current state of this chat
	 */
	readonly uiState: borogove_UiState;
	/**
	 * Is this chat blocked?
	 */
	readonly isBlocked: boolean;
	/**
	 * The most recent message in this chat
	 */
	readonly lastMessage: borogove_ChatMessage | null;
	/**
	 * Has this chat ever been bookmarked?
	 */
	readonly isBookmarked: boolean;
	/**
	 * Fetch a page of messages before some point
	 * @param beforeId id of the message to look before
	 * @param beforeTime timestamp of the message to look before,
	 * String in format YYYY-MM-DDThh:mm:ss[.sss]+00:00
	 * @returns Promise resolving to an array of ChatMessage that are found
	 */
	getMessagesBefore(beforeId: string | null, beforeTime: string | null): Promise<borogove_ChatMessage[]>;
	/**
	 * Fetch a page of messages after some point
	 * @param afterId id of the message to look after
	 * @param afterTime timestamp of the message to look after,
	 * String in format YYYY-MM-DDThh:mm:ss[.sss]+00:00
	 * @returns Promise resolving to an array of ChatMessage that are found
	 */
	getMessagesAfter(afterId: string | null, afterTime: string | null): Promise<borogove_ChatMessage[]>;
	/**
	 * Fetch a page of messages around (before, including, and after) some point
	 * @param aroundId id of the message to look around
	 * @param aroundTime timestamp of the message to look around,
	 * String in format YYYY-MM-DDThh:mm:ss[.sss]+00:00
	 * @returns Promise resolving to an array of ChatMessage that are found
	 */
	getMessagesAround(aroundId: string | null, aroundTime: string | null): Promise<borogove_ChatMessage[]>;
	/**
	 * Send a message to this Chat
	 * @param message the ChatMessageBuilder to send
	 */
	sendMessage(message: borogove_ChatMessageBuilder): void;
	/**
	 * Signals that all messages up to and including this one have probably
	 * been displayed to the user
	 * @param message the ChatMessage most recently displayed
	 */
	markReadUpTo(message: borogove_ChatMessage): void;
	/**
	 * Save this Chat on the server
	 */
	bookmark(): void;
	/**
	 * Get the list of IDs of participants in this Chat
	 * @returns array of IDs
	 */
	getParticipants(): string[];
	/**
	 * Get the details for one participant in this Chat
	 * @param participantId the ID of the participant to look up
	 */
	getParticipantDetails(participantId: string): borogove_Participant;
	/**
	 * Correct an already-send message by replacing it with a new one
	 * @param localId the localId of the message to correct
	 * must be the localId of the first version ever sent, not a subsequent correction
	 * @param message the new ChatMessage to replace it with
	 */
	correctMessage(localId: string, message: borogove_ChatMessageBuilder): void;
	/**
	 * Add new reaction to a message in this Chat
	 * @param m ChatMessage to react to
	 * @param reaction emoji of the reaction
	 */
	addReaction(m: borogove_ChatMessage, reaction: borogove_Reaction): void;
	/**
	 * Remove an already-sent reaction from a message
	 * @param m ChatMessage to remove the reaction from
	 * @param reaction the emoji to remove
	 */
	removeReaction(m: borogove_ChatMessage, reaction: borogove_Reaction): void;
	/**
	 * Call this whenever the user is typing, can call on every keystroke
	 * @param threadId optional, what thread the user has selected if any
	 * @param content optional, what the user has typed so far
	 */
	typing(threadId: string | null, content: string | null): void;
	/**
	 * Call this whenever the user makes a chat or thread "active" in your UX
	 * If you call this with true you MUST later call it will false
	 * @param active true if the chat is "active", false otherwise
	 * @param threadId optional, what thread the user has selected if any
	 */
	setActive(active: boolean, threadId: string | null): void;
	/**
	 * Archive this chat
	 */
	close(): void;
	/**
	 * Pin or unpin this chat
	 */
	togglePinned(): void;
	/**
	 * Block this chat so it will not re-open
	 */
	block(reportSpam?: boolean, spamMessage?: borogove_ChatMessage | null, onServer?: boolean): void;
	/**
	 * Unblock this chat so it will open again
	 */
	unblock(onServer?: boolean): void;
	/**
	 * Update notification preferences
	 */
	setNotifications(filtered: boolean, mention: boolean, reply: boolean): void;
	/**
	 * Should notifications be filtered?
	 */
	notificationsFiltered(): boolean;
	/**
	 * Should a mention produce a notification?
	 */
	notifyMention(): boolean;
	/**
	 * Should a reply produce a notification?
	 */
	notifyReply(): boolean;
	/**
	 * An ID of the most recent message in this chat
	 */
	lastMessageId(): string | null;
	/**
	 * Get the URI image to represent this Chat, or null
	 */
	getPhoto(): string | null;
	/**
	 * Get the URI to a placeholder image to represent this Chat
	 */
	getPlaceholder(): string;
	/**
	 * An ID of the last message displayed to the user
	 */
	readUpTo(): string | null;
	/**
	 * The number of message that have not yet been displayed to the user
	 */
	unreadCount(): number;
	/**
	 * A preview of the chat, such as the most recent message body
	 */
	preview(): string;
	/**
	 * Set the display name to use for this chat
	 * @param displayName String to use as display name
	 */
	setDisplayName(displayName: string): void;
	/**
	 * The display name of this Chat
	 */
	getDisplayName(): string;
	/**
	 * Set if this chat is to be trusted with our presence, etc
	 * @param trusted Bool if trusted or not
	 */
	setTrusted(trusted: boolean): void;
	/**
	 * Is this a chat with an entity we trust to see our online status?
	 */
	isTrusted(): boolean;
	/**
	 * @returns if this chat is currently syncing with the server
	 */
	syncing(): boolean;
	/**
	 * Can audio calls be started in this Chat?
	 */
	canAudioCall(): boolean;
	/**
	 * Can video calls be started in this Chat?
	 */
	canVideoCall(): boolean;
	/**
	 * Start a new call in this Chat
	 * @param audio do we want audio in this call
	 * @param video do we want video in this call
	 */
	startCall(audio: boolean, video: boolean): borogove_calls_Session;
	addMedia(streams: MediaStream[]): void;
	/**
	 * Accept any incoming calls in this Chat
	 */
	acceptCall(): void;
	/**
	 * Hangup or reject any calls in this chat
	 */
	hangup(): void;
	/**
	 * The current status of a call in this chat
	 */
	callStatus(): borogove_calls_CallStatus;
	/**
	 * A DTMFSender for a call in this chat, or NULL
	 */
	dtmf(): RTCDTMFSender | null;
	/**
	 * All video tracks in all active calls in this chat
	 */
	videoTracks(): MediaStreamTrack[];
	/**
	 * Get encryption mode for this chat
	 */
	encryptionMode(): string;
	/**
	 * Can the user send messages to this chat?
	 */
	canSend(): boolean;
	/**
	 * Invite another chat's participants to participate in this one
	 */
	invite(other: borogove_Chat, threadId?: string | null): void;
	/**
	 * Can the user invite others to this chat?
	 */
	canInvite(): boolean;
	/**
	 * This chat's primary mode of interaction is via commands
	 */
	isApp(): boolean;
	/**
	 * Does this chat provide a menu of commands?
	 */
	hasCommands(): boolean;
	commands(): Promise<borogove_Command[]>;
	/**
	 * The Participant that originally invited us to this Chat, if we were invited
	 */
	invitedBy(): borogove_Participant | null;
}

export class borogove_DirectChat extends borogove_Chat {
	protected constructor(client: borogove_Client, stream: borogove_GenericStream, persistence: borogove_Persistence, chatId: string, uiState?: borogove_UiState, isBookmarked?: boolean, isBlocked?: boolean, extensions?: borogove_Stanza | null, readUpToId?: string | null, readUpToBy?: string | null, omemoContactDeviceIDs?: number[] | null);
	getParticipants(): string[];
	getParticipantDetails(participantId: string): borogove_Participant;
	getMessagesBefore(beforeId: string | null, beforeTime: string | null): Promise<borogove_ChatMessage[]>;
	getMessagesAfter(afterId: string | null, afterTime: string | null): Promise<borogove_ChatMessage[]>;
	getMessagesAround(aroundId: string | null, aroundTime: string | null): Promise<borogove_ChatMessage[]>;
	correctMessage(localId: string, message: borogove_ChatMessageBuilder): void;
	sendMessage(message: borogove_ChatMessageBuilder): void;
	removeReaction(m: borogove_ChatMessage, reaction: borogove_Reaction): void;
	lastMessageId(): string | null;
	markReadUpTo(message: borogove_ChatMessage): void;
	bookmark(): void;
	close(): void;
}

export class borogove_Channel extends borogove_Chat {
	protected constructor(client: borogove_Client, stream: borogove_GenericStream, persistence: borogove_Persistence, chatId: string, uiState?: borogove_UiState, isBookmarked?: boolean, isBlocked?: boolean, extensions?: borogove_Stanza | null, readUpToId?: string | null, readUpToBy?: string | null, disco?: borogove_Caps | null);
	getDisplayName(): string;
	description(): string;
	invite(chat: borogove_Chat, threadId?: string | null): void;
	canInvite(): boolean;
	canSend(): boolean;
	setTrusted(trusted: boolean): void;
	isTrusted(): boolean;
	isPrivate(): boolean;
	preview(): string;
	syncing(): boolean;
	canAudioCall(): boolean;
	canVideoCall(): boolean;
	getParticipants(): string[];
	getParticipantDetails(participantId: string): borogove_Participant;
	getMessagesBefore(beforeId: string | null, beforeTime: string | null): Promise<borogove_ChatMessage[]>;
	getMessagesAfter(afterId: string | null, afterTime: string | null): Promise<borogove_ChatMessage[]>;
	getMessagesAround(aroundId: string | null, aroundTime: string | null): Promise<borogove_ChatMessage[]>;
	correctMessage(localId: string, message: borogove_ChatMessageBuilder): void;
	sendMessage(message: borogove_ChatMessageBuilder): void;
	removeReaction(m: borogove_ChatMessage, reaction: borogove_Reaction): void;
	lastMessageId(): string | null;
	markReadUpTo(message: borogove_ChatMessage): void;
	bookmark(): void;
	close(): void;
}

export class borogove_AvailableChat {
	protected constructor(chatId: string, displayName: string | null, note: string, caps: borogove_Caps);
	/**
	 * The ID of the Chat this search result represents
	 */
	chatId: string;
	/**
	 * The display name of this search result
	 */
	displayName: string | null;
	/**
	 * A human-readable note associated with this search result
	 */
	note: string;
	/**
	 * Is this search result a channel?
	 */
	isChannel(): boolean;
}

export class borogove_SerializedChat {
	constructor(chatId: string, trusted: boolean, isBookmarked: boolean, avatarSha1: ArrayBuffer | null, presence: Map<string,borogove_Presence>, displayName: string | null, uiState: borogove_UiState | null, isBlocked: boolean | null, extensions: string | null, readUpToId: string | null, readUpToBy: string | null, notificationsFiltered: boolean | null, notifyMention: boolean, notifyReply: boolean, disco: borogove_Caps | null, omemoContactDeviceIDs: number[], klass: string);
	chatId: string;
	trusted: boolean;
	isBookmarked: boolean;
	avatarSha1: ArrayBuffer | null;
	presence: Map<string,borogove_Presence>;
	displayName: string | null;
	uiState: borogove_UiState;
	isBlocked: boolean;
	extensions: string;
	readUpToId: string | null;
	readUpToBy: string | null;
	disco: borogove_Caps | null;
	omemoContactDeviceIDs: number[];
	klass: string;
	notificationsFiltered: boolean | null;
	notifyMention: boolean;
	notifyReply: boolean;
	toChat(client: borogove_Client, stream: borogove_GenericStream, persistence: borogove_Persistence): borogove_Chat;
}

export class borogove_LinkMetadata {
	protected constructor(about: string, url: string | null, title: string | null, description: string | null, image: string[], video: string[]);
	about: string;
	url: string;
	title: string | null;
	description: string | null;
	image: string[];
	video: string[];
}

export class borogove_ChatAttachment {
	constructor(name: string | null, mime: string, size: number | null, uris: string[], hashes: borogove_Hash[]);
	/**
	 * Filename
	 */
	name: string | null;
	/**
	 * MIME Type
	 */
	mime: string;
	/**
	 * Size in bytes
	 */
	size: number | null;
	/**
	 * URIs to data
	 */
	uris: string[];
	/**
	 * Hashes of data
	 */
	hashes: borogove_Hash[];
}

export class borogove_EncryptionInfo {
	protected constructor(status: borogove_EncryptionStatus, method: string, methodName?: string | null, reason?: string | null, reasonText?: string | null);
	status: borogove_EncryptionStatus;
	method: string;
	methodName: string | null;
	reason: string | null;
	reasonText: string | null;
}

export class borogove_ChatMessage {
	protected constructor(params: {attachments?: borogove_ChatAttachment[] | null, direction?: borogove_MessageDirection | null, encryption?: borogove_EncryptionInfo | null, from: borogove_JID, lang?: string | null, linkMetadata?: borogove_LinkMetadata[] | null, localId?: string | null, payloads?: borogove_Stanza[] | null, reactions?: Map<string,borogove_Reaction[]> | null, recipients?: borogove_JID[] | null, replyId?: string | null, replyTo?: borogove_JID[] | null, replyToMessage?: borogove_ChatMessage | null, senderId: string, serverId?: string | null, serverIdBy?: string | null, stanza?: borogove_Stanza | null, status?: borogove_MessageStatus | null, statusText?: string | null, syncPoint?: boolean | null, text?: string | null, threadId?: string | null, timestamp: string, to: borogove_JID, type?: borogove_MessageType | null, versions?: borogove_ChatMessage[] | null});
	/**
	 * The ID as set by the creator of this message
	 */
	localId: string | null;
	/**
	 * The ID as set by the authoritative server
	 */
	serverId: string | null;
	/**
	 * The ID of the server which set the serverId
	 */
	serverIdBy: string | null;
	/**
	 * The type of this message (Chat, Call, etc)
	 */
	type: borogove_MessageType;
	/**
	 * The timestamp of this message, in format YYYY-MM-DDThh:mm:ss[.sss]Z
	 */
	timestamp: string;
	/**
	 * The ID of the sender of this message
	 */
	senderId: string;
	/**
	 * Message this one is in reply to, or NULL
	 */
	readonly replyToMessage: borogove_ChatMessage | null;
	/**
	 * ID of the thread this message is in, or NULL
	 */
	threadId: string | null;
	/**
	 * Array of attachments to this message
	 */
	attachments: borogove_ChatAttachment[];
	/**
	 * Map of reactions to this message
	 */
	readonly reactions: Map<string,borogove_Reaction[]>;
	/**
	 * Body text of this message or NULL
	 */
	text: string | null;
	/**
	 * Language code for the body text
	 */
	lang: string | null;
	/**
	 * Direction of this message
	 */
	direction: borogove_MessageDirection;
	/**
	 * Status of this message
	 */
	status: borogove_MessageStatus;
	/**
	 * Message to go along with the message status
	 */
	statusText: string | null;
	/**
	 * Array of past versions of this message, if it has been edited
	 */
	versions: borogove_ChatMessage[];
	/**
	 * Information about the encryption used by the sender of
	 * this message.
	 */
	encryption: borogove_EncryptionInfo | null;
	/**
	 * Metadata about links associated with this message
	 */
	linkMetadata: borogove_LinkMetadata[];
	/**
	 * Create a new ChatMessage in reply to this one
	 */
	reply(): borogove_ChatMessageBuilder;
	/**
	 * Get HTML version of the message body
	 * WARNING: this is possibly untrusted HTML. You must parse or sanitize appropriately!
	 * @param sender optionally specify the full details of the sender
	 */
	html(sender?: borogove_Participant | null): string;
	/**
	 * The ID of the Chat this message is associated with
	 */
	chatId(): string;
	/**
	 * The ID of the account associated with this message
	 */
	account(): string;
	/**
	 * Is this an incoming message?
	 */
	isIncoming(): boolean;
	/**
	 * The URI of an icon for the thread associated with this message, or NULL
	 */
	threadIcon(): string | null | null;
	/**
	 * The last status of the call if this message is related to a call
	 */
	callStatus(): string | null;
	/**
	 * The session id of the call if this message is related to a call
	 */
	callSid(): string | null;
	/**
	 * The duration of the call if this message is related to a call
	 */
	callDuration(): string | null;
}

export class borogove_ChatMessageBuilder {
	/**
	 * @returns a new blank ChatMessageBuilder
	 */
	constructor(params?: {attachments?: borogove_ChatAttachment[] | null, direction?: borogove_MessageDirection | null, encryption?: borogove_EncryptionInfo | null, html?: string | null, lang?: string | null, localId?: string | null, payloads?: borogove_Stanza[] | null, reactions?: Map<string,borogove_Reaction[]> | null, replyId?: string | null, replyToMessage?: borogove_ChatMessage | null, senderId?: string | null, serverId?: string | null, serverIdBy?: string | null, status?: borogove_MessageStatus | null, syncPoint?: boolean | null, text?: string | null, threadId?: string | null, timestamp?: string | null, type?: borogove_MessageType | null, versions?: borogove_ChatMessage[] | null} | null);
	/**
	 * The ID as set by the creator of this message
	 */
	localId: string | null;
	/**
	 * The ID as set by the authoritative server
	 */
	serverId: string | null;
	/**
	 * The ID of the server which set the serverId
	 */
	serverIdBy: string | null;
	/**
	 * The type of this message (Chat, Call, etc)
	 */
	type: borogove_MessageType;
	/**
	 * The timestamp of this message, in format YYYY-MM-DDThh:mm:ss[.sss]+00:00
	 */
	timestamp: string | null;
	/**
	 * The ID of the message sender
	 */
	/**
	 * Message this one is in reply to, or NULL
	 */
	replyToMessage: borogove_ChatMessage | null;
	/**
	 * ID of the thread this message is in, or NULL
	 */
	threadId: string | null;
	/**
	 * Array of attachments to this message
	 */
	readonly attachments: borogove_ChatAttachment[];
	/**
	 * Map of reactions to this message
	 */
	reactions: Map<string,borogove_Reaction[]>;
	/**
	 * Body text of this message or NULL
	 */
	text: string | null;
	/**
	 * Language code for the body text
	 */
	lang: string | null;
	/**
	 * Direction of this message
	 */
	direction: borogove_MessageDirection;
	/**
	 * Status of this message
	 */
	status: borogove_MessageStatus;
	/**
	 * Human readable text to go with the status
	 */
	statusText: string | null;
	/**
	 * Array of past versions of this message, if it has been edited
	 */
	versions: borogove_ChatMessage[];
	/**
	 * Information about the encryption used by the sender of
	 * this message.
	 */
	encryption: borogove_EncryptionInfo | null;
	/**
	 * Metadata about links associated with this message
	 */
	linkMetadata: borogove_LinkMetadata[];
	/**
	 * Add an attachment to this message
	 * @param attachment The ChatAttachment to add
	 */
	addAttachment(attachment: borogove_ChatAttachment): void;
	/**
	 * Set rich text using an HTML string
	 * Also sets the plain text body appropriately
	 */
	setHtml(html: string): void;
	/**
	 * The ID of the Chat this message is associated with
	 */
	chatId(): string;
	/**
	 * The ID of the sender of this message
	 */
	get_senderId(): string;
	/**
	 * Build this builder into an immutable ChatMessage
	 * @returns the ChatMessage
	 */
	build(): borogove_ChatMessage;
}

export class borogove_EventEmitter {
	protected constructor();
	/**
	 * Remove an event listener of any type, no matter how it was added
	 * or what event it is for.
	 * @param token the token that was returned when the listener was added
	 */
	removeEventListener(token: number): void;
}

export class borogove_Client extends borogove_EventEmitter {
	/**
	 * Create a new Client to connect to a particular account
	 * @param accountId the account to connect to
	 * @param persistence the persistence layer to use for storage
	 */
	constructor(accountId: string, persistence: borogove_Persistence);
	/**
	 * Set to false to suppress sending available presence
	 */
	sendAvailable: boolean;
	/**
	 * Start this client running and trying to connect to the server
	 */
	start(): void;
	/**
	 * Gets the client ready to use but does not connect to the server
	 * @returns Promise resolving to true once the Client is ready
	 */
	startOffline(): Promise<boolean>;
	/**
	 * Destroy local data for this account
	 * @param completely if true chats, messages, etc will be deleted as well
	 */
	logout(completely: boolean): void;
	/**
	 * Sets the password to be used in response to the password needed event
	 * @param password
	 */
	usePassword(password: string): void;
	/**
	 * Get the account ID for this Client
	 * @returns account id
	 */
	accountId(): string;
	/**
	 * Get the current display name for this account
	 * @returns display name
	 */
	displayName(): string;
	/**
	 * Set the current profile for this account on the server
	 * @param profile to set
	 * @param publicAccess set the access for the profile to public
	 */
	setProfile(profile: borogove_ProfileBuilder, publicAccess: boolean): void;
	/**
	 * Turn a file into a ChatAttachment for attaching to a ChatMessage
	 * @param source The AttachmentSource to use
	 * @returns Promise resolving to a ChatAttachment or null
	 */
	prepareAttachment(source: File): Promise<borogove_ChatAttachment | null>;
	/**
	 * @returns array of open chats, sorted by last activity
	 */
	getChats(): borogove_Chat[];
	/**
	 * Search for chats the user can start or join
	 * @param q the search query to use
	 * @param callback takes two arguments, the query that was used and the array of results, and returns true if we should stop searching
	 */
	findAvailableChats(q: string, callback: (arg0: string, arg1: borogove_AvailableChat[]) => boolean): void;
	/**
	 * Start or join a chat from the search results
	 * @returns the chat that was started
	 */
	startChat(availableChat: borogove_AvailableChat): borogove_Chat;
	/**
	 * Find a chat by id
	 * @returns the chat if known, or NULL
	 */
	getChat(chatId: string): borogove_Chat | null;
	subscribePush(reg: ServiceWorkerRegistration, push_service: string, vapid_key: {privateKey: CryptoKey, publicKey: CryptoKey}, grace?: number | null): void;
	/**
	 * Enable push notifications
	 * @param push_service the address of a push proxy
	 * @param vapid_private_pkcs8 the private key for signing JWT of the push service
	 * @param endpoint the final target for the push proxy to forward to
	 * @param p256dh A P-256 uncompressed point in ANSI X9.62 format
	 * @param auth Random 16 octed value
	 * @param grace Grace period during which not to generate push if another app is active for same account, in seconds (negative for none)
	 * @param claims Optional additional JWT claims as key then value
	 */
	enablePush(push_service: string, endpoint: string, p256dh: ArrayBuffer, auth: ArrayBuffer, grace: number, vapid_private_pkcs8?: ArrayBuffer | null, claims?: string[] | null): void;
	/**
	 * Event fired when client needs a password for authentication
	 * @param handler takes one argument, the Client that needs a password
	 * @returns token for use with removeEventListener
	 */
	addPasswordNeededListener(handler: (arg0: borogove_Client) => void): number;
	/**
	 * Event fired when client is connected and fully synchronized
	 * @param handler takes no arguments
	 * @returns token for use with removeEventListener
	 */
	addStatusOnlineListener(handler: () => void): number;
	/**
	 * Event fired when client is disconnected
	 * @param handler takes no arguments
	 * @returns token for use with removeEventListener
	 */
	addStatusOfflineListener(handler: () => void): number;
	/**
	 * Event fired when connection fails with a fatal error and will not be retried
	 * @param handler takes no arguments
	 * @returns token for use with removeEventListener
	 */
	addConnectionFailedListener(handler: () => void): number;
	/**
	 * Event fired when TLS checks fail, to give client the chance to override
	 * @param handler takes two arguments, the PEM of the cert and an array of DNS names, and must return true to accept or false to reject
	 * @returns token for use with removeEventListener
	 */
	addTlsCheckListener(handler: (arg0: string, arg1: string[]) => boolean): number;
	addUserStateListener(handler: (arg0: string, arg1: string, arg2: string | null, arg3: borogove_UserState) => void): number;
	/**
	 * Event fired when a new ChatMessage comes in on any Chat
	 * Also fires when status of a ChatMessage changes,
	 * when a ChatMessage is edited, or when a reaction is added
	 * @param handler takes two arguments, the ChatMessage and ChatMessageEvent enum describing what happened
	 * @returns token for use with removeEventListener
	 */
	addChatMessageListener(handler: (arg0: borogove_ChatMessage, arg1: borogove_ChatMessageEvent) => void): number;
	/**
	 * Event fired when syncing a new ChatMessage that was send when offline.
	 * Normally you don't want this, but it may be useful if you want to notify on app start.
	 * @param handler takes one argument, the ChatMessage
	 * @returns token for use with removeEventListener
	 */
	addSyncMessageListener(handler: (arg0: borogove_ChatMessage) => void): number;
	/**
	 * Event fired when a Chat's metadata is updated, or when a new Chat is added
	 * @param handler takes one argument, an array of Chats that were updated
	 * @returns token for use with removeEventListener
	 */
	addChatsUpdatedListener(handler: (arg0: borogove_Chat[]) => void): number;
	/**
	 * Event fired when a new call comes in
	 * @param handler takes one argument, the call Session
	 * @returns token for use with removeEventListener
	 */
	addCallRingListener(handler: (arg0: borogove_calls_Session) => void): number;
	/**
	 * Event fired when a call is retracted or hung up
	 * @param handler takes two arguments, the associated Chat ID and Session ID
	 * @returns token for use with removeEventListener
	 */
	addCallRetractListener(handler: (arg0: string, arg1: string) => void): number;
	/**
	 * Event fired when an outgoing call starts ringing
	 * @param handler takes one argument, the associated Session
	 * @returns token for use with removeEventListener
	 */
	addCallRingingListener(handler: (arg0: borogove_calls_Session) => void): number;
	/**
	 * Event fired when an existing call changes status (connecting, failed, etc)
	 * @param handler takes one argument, the associated Session
	 * @returns token for use with removeEventListener
	 */
	addCallUpdateStatusListener(handler: (arg0: borogove_calls_InitiatedSession) => void): number;
	/**
	 * Event fired when a call is asking for media to send
	 * @param handler takes three arguments, the call Session,
	 * a boolean indicating if audio is desired,
	 * and a boolean indicating if video is desired
	 * @returns token for use with removeEventListener
	 */
	addCallMediaListener(handler: (arg0: borogove_calls_InitiatedSession, arg1: boolean, arg2: boolean) => void): number;
	/**
	 * Event fired when call has a new MediaStreamTrack to play
	 * @param handler takes three arguments, the associated Chat ID,
	 * the new MediaStreamTrack, and an array of any associated MediaStreams
	 * @returns token for use with removeEventListener
	 */
	addCallTrackListener(handler: (arg0: borogove_calls_InitiatedSession, arg1: MediaStreamTrack, arg2: MediaStream[]) => void): number;
	/**
	 * Let the SDK know the UI is in the foreground
	 */
	setInForeground(): void;
	/**
	 * Let the SDK know the UI is in the foreground
	 */
	setNotInForeground(): void;
}

export class borogove_Command {
	protected constructor(client: borogove_Client, params: {jid: borogove_JID, name: string | null, node: string});
	name: string;
	/**
	 * Start a new session for this command. May have side effects!
	 */
	execute(): Promise<borogove_CommandSession>;
}

export class borogove_CommandSession {
	protected constructor(status: string, sessionid: string, actions: borogove_FormOption[], forms: borogove_Form[], command: borogove_Command);
	name: string;
	status: string;
	actions: borogove_FormOption[];
	forms: borogove_Form[];
	execute(action?: string | null, data?: { [key: string]: string | string[] } | Map<string,string | string[]> | FormData | null, formIdx?: number): Promise<borogove_CommandSession>;
}

export class borogove_Config {
	protected constructor();
	/**
	 * Produce /.well-known/ni/ paths instead of ni:/// URIs
	 * for referencing media by hash.
	 * This can be useful eg for intercepting with a Service Worker.
	 */
	static relativeHashUri: boolean;
}

export class borogove_FormField {
	protected constructor(field: borogove_Stanza);
	name: string;
	label: string | null;
	desc: string | null;
	value: string[];
	required: boolean;
	type: string;
	datatype: string;
	options: borogove_FormOption[];
	open: boolean;
	rangeMin: string | null;
	rangeMax: string | null;
	regex: string | null;
}

export class borogove_FormOption {
	protected constructor(label: string | null, value: string | null);
	label: string;
	value: string;
}

export interface borogove_FormSection {
	title(): string | null;
	items(): borogove_FormItem[];
}

export class borogove_FormItem {
	protected constructor(text: string | null, field: borogove_FormField | null, section: borogove_FormSection | null, tableHeader?: borogove_FormField[] | null, tableRows?: borogove_FormField[][] | null, status?: string | null);
	text: string | null;
	field: borogove_FormField | null;
	section: borogove_FormSection | null;
	status: string | null;
	tableHeader: borogove_FormField[] | null;
	tableRows: borogove_FormField[][] | null;
}

export class borogove_Form implements borogove_FormSection {
	protected constructor(form: borogove_Stanza | null, oob: borogove_Stanza | null);
	/**
	 * Is this form entirely results / read-only?
	 */
	isResult(): boolean;
	/**
	 * Title of this form
	 */
	title(): string | null;
	/**
	 * URL to use instead of this form
	 */
	url(): string | null;
	/**
	 * Items to render inside this form
	 */
	items(): borogove_FormItem[];
}

export class borogove_Hash {
	protected constructor(algorithm: string, hash: ArrayBuffer);
	/**
	 * Hash algorithm name
	 */
	algorithm: string;
	/**
	 * Represent this Hash as a URI
	 * @returns URI as a string
	 */
	toUri(): string;
	/**
	 * Represent this Hash as a hex string
	 * @returns hex string
	 */
	toHex(): string;
	/**
	 * Represent this Hash as a Base64 string
	 * @returns Base64-encoded string
	 */
	toBase64(): string;
	/**
	 * Represent this Hash as a Base64url string
	 * @returns Base64url-encoded string
	 */
	toBase64Url(): string;
	/**
	 * Create a new Hash from a hex string
	 * @param algorithm name per https://xmpp.org/extensions/xep-0300.html
	 * @param hash in hex format
	 * @returns Hash or null on error
	 */
	static fromHex(algorithm: string, hash: string): borogove_Hash | null;
	/**
	 * Create a new Hash from a ni:, cid: or similar URI
	 * @param uri The URI
	 * @returns Hash or null on error
	 */
	static fromUri(uri: string): borogove_Hash | null;
}

export class borogove_Identicon {
	protected constructor();
	static svg(source: string): string;
}

export class borogove_JID {
	constructor(node: string | null, domain: string, resource?: string | null, raw?: boolean | null);
	node: string | null;
	domain: string;
	resource: string | null;
	asBare(): borogove_JID;
	withResource(resource: string): borogove_JID;
	isValid(): boolean;
	isDomain(): boolean;
	isBare(): boolean;
	equals(rhs: borogove_JID): boolean;
	asString(): string;
	static parse(jid: string): borogove_JID;
}

export class borogove_Notification {
	protected constructor(title: string, body: string, accountId: string, chatId: string, senderId: string, messageId: string, type: borogove_MessageType, callStatus: string | null, callSid: string | null, imageUri: string | null, lang: string | null, timestamp: string | null);
	/**
	 * The title
	 */
	title: string;
	/**
	 * The body text
	 */
	body: string;
	/**
	 * The ID of the associated account
	 */
	accountId: string;
	/**
	 * The ID of the associated chat
	 */
	chatId: string;
	/**
	 * The ID of the message sender
	 */
	senderId: string;
	/**
	 * The serverId of the message
	 */
	messageId: string;
	/**
	 * The type of the message
	 */
	type: borogove_MessageType;
	/**
	 * If this is a call notification, the call status
	 */
	callStatus: string | null;
	/**
	 * If this is a call notification, the call session ID
	 */
	callSid: string | null;
	/**
	 * Optional image URI
	 */
	imageUri: string | null;
	/**
	 * Optional language code
	 */
	lang: string | null;
	/**
	 * Optional date and time of the event
	 */
	timestamp: string | null;
}

export class borogove_Participant {
	protected constructor(displayName: string, photoUri: string | null, placeholderUri: string, isSelf: boolean, jid: borogove_JID);
	displayName: string;
	photoUri: string | null;
	placeholderUri: string;
	isSelf: boolean;
	profile(client: borogove_Client): Promise<borogove_Profile>;
}

export class borogove_Presence {
	constructor(caps: borogove_Caps | null, mucUser: borogove_Stanza | null, avatarHash: borogove_Hash | null);
	caps: borogove_Caps | null;
	mucUser: borogove_Stanza | null;
	avatarHash: borogove_Hash | null;
}

export class borogove_Profile {
	protected constructor(vcard: borogove_Stanza, items?: borogove_ProfileItem[] | null);
	/**
	 * All items in the profile
	 */
	items: borogove_ProfileItem[];
}

export class borogove_ProfileItem {
	protected constructor(item: borogove_Stanza, id: string);
	id: string;
	key: string;
	parameters(): borogove_ProfileItem[];
	text(): string[];
	uri(): string[];
	date(): string[];
	time(): string[];
	datetime(): string[];
	boolean(): boolean[];
	integer(): number[];
	languageTag(): string[];
}

export class borogove_ProfileBuilder {
	constructor(profile: borogove_Profile);
	/**
	 * Add a new field to this profile
	 */
	add(k: string, v: string): void;
	/**
	 * Set the value of an existing field on this profile
	 */
	set(id: string, v: string): void;
	/**
	 * Move a profile item
	 * @param id the item to move
	 * @param moveTo the item currently in the position where it should move to
	 */
	move(id: string, moveTo: string): void;
	/**
	 * Remove a field from this profile
	 */
	remove(id: string): void;
	build(): borogove_Profile;
}

export class borogove_Push {
	protected constructor();
	/**
	 * Receive a new push notification from some external system
	 * @param data the raw data from the push
	 * @param persistence the persistence layer to write into
	 * @returns a Notification representing the push data
	 */
	static receive(data: string, persistence: borogove_Persistence): borogove_Notification | null;
}

export class borogove_Reaction {
	protected constructor(senderId: string, timestamp: string, text: string, envelopeId?: string | null, key?: string | null);
	/**
	 * ID of who sent this Reaction
	 */
	senderId: string;
	/**
	 * Date and time when this Reaction was sent,
	 * in format YYYY-MM-DDThh:mm:ss[.sss]+00:00
	 */
	timestamp: string;
	/**
	 * Key for grouping reactions
	 */
	key: string;
	/**
	 * Create a new Unicode reaction to send
	 * @param forText Callback called if this is a textual reaction.
	 * Called with the unicode String.
	 * @param forImage Callback called if this is a custom/image reaction.
	 * Called with the name and the URI to the image.
	 * @returns the return value of the callback
	 */
	render<T>(forText: (arg0: string) => T, forImage: (arg0: string, arg1: string) => T): T;
	/**
	 * Create a new Unicode reaction to send
	 * @param unicode emoji of the reaction
	 * @returns Reaction
	 */
	static unicode(unicode: string): borogove_Reaction;
}

export class borogove_CustomEmojiReaction extends borogove_Reaction {
	protected constructor(senderId: string, timestamp: string, text: string, uri: string, envelopeId?: string | null);
	uri: string;
	render<T>(forText: (arg0: string) => T, forImage: (arg0: string, arg1: string) => T): T;
	/**
	 * Create a new custom emoji reaction to send
	 * @param text name of custom emoji
	 * @param uri URI for media of custom emoji
	 * @returns Reaction
	 */
	static custom(text: string, uri: string): borogove_CustomEmojiReaction;
}

export class borogove_ReactionUpdate {
	constructor(updateId: string, serverId: string | null, serverIdBy: string | null, localId: string | null, chatId: string, senderId: string, timestamp: string, reactions: borogove_Reaction[], kind: borogove_ReactionUpdateKind);
	updateId: string;
	serverId: string | null;
	serverIdBy: string | null;
	localId: string | null;
	chatId: string;
	senderId: string;
	timestamp: string;
	reactions: borogove_Reaction[];
	kind: borogove_ReactionUpdateKind;
	getReactions(existingReactions: borogove_Reaction[] | null): borogove_Reaction[];
}

export class borogove_Register {
	protected constructor(domain: string, preAuth: string | null, username: string | null);
	/**
	 * Fetch registration form options from the server.
	 * If you already know what fields your server wants, this is optional.
	 */
	getForm(): Promise<borogove_Form[]>;
	/**
	 * Submit registration data to the server
	 */
	submit(data: { [key: string]: string | string[] } | Map<string,string | string[]> | FormData): Promise<string>;
	/**
	 * Disconnect from the server after registration is done
	 */
	disconnect(): void;
	/**
	 * Start new registration flow for a given domain or invite URL
	 */
	static fromDomainOrInvite(domainOrInvite: string): Promise<borogove_Register>;
}

export class borogove_StanzaError {
	constructor(type_: string, condition_: string, text_?: string | null);
	type: string;
	condition: string;
	text: string | null;
}

export class borogove_Stanza {
	constructor(name: string, attr?: { [key: string]: string } | null);
	name: string;
	attr: { [key: string]: string };
	readonly children: any[];
	serialize(): string;
	toString(): string;
	tag(name: string, attr?: { [key: string]: string } | null): borogove_Stanza;
	text(content: string): borogove_Stanza;
	textTag(tagName: string, textContent: string, attr?: { [key: string]: string } | null): borogove_Stanza;
	up(): borogove_Stanza;
	reset(): borogove_Stanza;
	insertChild(idx: number, stanza: borogove_Stanza): borogove_Stanza;
	addChild(stanza: borogove_Stanza): borogove_Stanza;
	addDirectChild(child: any): borogove_Stanza;
	clone(): borogove_Stanza;
	allTags(name?: string | null, xmlns?: string | null): borogove_Stanza[];
	allText(): string[];
	getFirstChild(): borogove_Stanza;
	getErrorText(): string;
	getChild(name?: string | null, xmlns?: string | null): borogove_Stanza | null;
	getChildText(name?: string | null, xmlns?: string | null): string | null;
	hasChild(name?: string | null, xmlns?: string | null): boolean;
	getText(): string;
	find(path: string): any | null;
	findChild(path: string): borogove_Stanza;
	findText(path: string): string | null;
	traverse(f: (arg0: borogove_Stanza) => boolean): borogove_Stanza;
	getError(): borogove_StanzaError | null;
	removeChild(remove: borogove_Stanza): void;
	removeChildren(name?: string | null, xmlns_?: string | null): void;
	static parse(s: string): borogove_Stanza;
	static parseXmlBool(x: string): boolean;
}

export class borogove_Version {
	protected constructor();
	static readonly HUMAN: string;
}

export interface borogove_calls_Session {
	get_sid(): string;
	get_chatId(): string;
	accept(): void;
	hangup(): void;
	addMedia(streams: MediaStream[]): void;
	callStatus(): borogove_calls_CallStatus;
	audioTracks(): MediaStreamTrack[];
	videoTracks(): MediaStreamTrack[];
	dtmf(): RTCDTMFSender | null;
}

export class borogove_calls_Attribute {
	constructor(key: string, value: string);
	readonly key: string;
	readonly value: string;
	toSdp(): string;
	toString(): string;
	static parse(input: string): borogove_calls_Attribute;
}

export class borogove_calls_Media {
	constructor(mid: string, media: string, connectionData: string, port: string, protocol: string, attributes: borogove_calls_Attribute[], formats: number[]);
	readonly mid: string;
	readonly media: string;
	readonly connectionData: string;
	readonly port: string;
	readonly protocol: string;
	readonly attributes: borogove_calls_Attribute[];
	readonly formats: number[];
	toSdp(): string;
	contentElement(initiator: boolean): borogove_Stanza;
	toElement(sessionAttributes: borogove_calls_Attribute[], initiator: boolean): borogove_Stanza;
	getUfragPwd(sessionAttributes?: borogove_calls_Attribute[] | null): {pwd: string, ufrag: string};
	toTransportElement(sessionAttributes: borogove_calls_Attribute[]): borogove_Stanza;
	static fromElement(content: borogove_Stanza, initiator: boolean, hasGroup: boolean, existingDescription?: borogove_calls_SessionDescription | null): borogove_calls_Media;
}

export class borogove_calls_SessionDescription {
	constructor(version: number, name: string, media: borogove_calls_Media[], attributes: borogove_calls_Attribute[], identificationTags: string[]);
	readonly version: number;
	readonly name: string;
	readonly media: borogove_calls_Media[];
	readonly attributes: borogove_calls_Attribute[];
	readonly identificationTags: string[];
	getUfragPwd(): {pwd: string, ufrag: string} | null;
	getFingerprint(): borogove_calls_Attribute | null;
	getDtlsSetup(): string;
	addContent(newDescription: borogove_calls_SessionDescription): borogove_calls_SessionDescription;
	toSdp(): string;
	toStanza(action: string, sid: string, initiator: boolean): borogove_Stanza;
	static parse(input: string): borogove_calls_SessionDescription;
	static fromStanza(iq: borogove_Stanza, initiator: boolean, existingDescription?: borogove_calls_SessionDescription | null): borogove_calls_SessionDescription;
}

export class borogove_calls_InitiatedSession implements borogove_calls_Session {
	protected constructor(client: borogove_Client, counterpart: borogove_JID, sid: string, remoteDescription: borogove_calls_SessionDescription | null);
	get_sid(): string;
	get_chatId(): string;
	accept(): void;
	hangup(): void;
	addMedia(streams: MediaStream[]): void;
	callStatus(): borogove_calls_CallStatus;
	audioTracks(): MediaStreamTrack[];
	videoTracks(): MediaStreamTrack[];
	dtmf(): RTCDTMFSender | null;
	supplyMedia(streams: MediaStream[]): void;
}

export interface borogove_Persistence {
	lastId(accountId: string, chatId: string | null): Promise<string | null>;
	storeChats(accountId: string, chats: borogove_Chat[]): void;
	getChats(accountId: string): Promise<borogove_SerializedChat[]>;
	getChatsUnreadDetails(accountId: string, chats: borogove_Chat[]): Promise<{chatId: string, message: borogove_ChatMessage, unreadCount: number}[]>;
	storeReaction(accountId: string, update: borogove_ReactionUpdate): Promise<borogove_ChatMessage | null>;
	storeMessages(accountId: string, message: borogove_ChatMessage[]): Promise<borogove_ChatMessage[]>;
	updateMessage(accountId: string, message: borogove_ChatMessage): void;
	updateMessageStatus(accountId: string, localId: string, status: borogove_MessageStatus, statusText: string | null): Promise<borogove_ChatMessage>;
	getMessage(accountId: string, chatId: string, serverId: string | null, localId: string | null): Promise<borogove_ChatMessage | null>;
	getMessagesBefore(accountId: string, chatId: string, beforeId: string | null, beforeTime: string | null): Promise<borogove_ChatMessage[]>;
	getMessagesAfter(accountId: string, chatId: string, afterId: string | null, afterTime: string | null): Promise<borogove_ChatMessage[]>;
	getMessagesAround(accountId: string, chatId: string, aroundId: string | null, aroundTime: string | null): Promise<borogove_ChatMessage[]>;
	hasMedia(hashAlgorithm: string, hash: ArrayBuffer): Promise<boolean>;
	storeMedia(mime: string, bytes: ArrayBuffer): Promise<boolean>;
	removeMedia(hashAlgorithm: string, hash: ArrayBuffer): void;
	storeCaps(caps: borogove_Caps): void;
	getCaps(ver: string): Promise<borogove_Caps | null>;
	storeLogin(login: string, clientId: string, displayName: string, token: string | null): void;
	getLogin(login: string): Promise<{clientId: string | null, displayName: string | null, fastCount: number, token: string | null}>;
	removeAccount(accountId: string, completely: boolean): void;
	listAccounts(): Promise<string[]>;
	storeStreamManagement(accountId: string, data: ArrayBuffer | null): void;
	getStreamManagement(accountId: string): Promise<ArrayBuffer | null>;
	storeService(accountId: string, serviceId: string, name: string | null, node: string | null, caps: borogove_Caps): void;
	findServicesWithFeature(accountId: string, feature: string): Promise<{caps: borogove_Caps, name: string | null, node: string | null, serviceId: string}[]>;
}

export class borogove_persistence_Dummy implements borogove_Persistence {
	/**
	 * Create a basic persistence layer that persists nothing
	 * @returns new persistence layer
	 */
	constructor();
	lastId(accountId: string, chatId: string | null): Promise<string | null>;
	storeChats(accountId: string, chat: borogove_Chat[]): void;
	getChats(accountId: string): Promise<borogove_SerializedChat[]>;
	storeMessages(accountId: string, messages: borogove_ChatMessage[]): Promise<borogove_ChatMessage[]>;
	updateMessage(accountId: string, message: borogove_ChatMessage): void;
	getMessage(accountId: string, chatId: string, serverId: string | null, localId: string | null): Promise<borogove_ChatMessage | null>;
	getMessagesBefore(accountId: string, chatId: string, beforeId: string | null, beforeTime: string | null): Promise<borogove_ChatMessage[]>;
	getMessagesAfter(accountId: string, chatId: string, afterId: string | null, afterTime: string | null): Promise<borogove_ChatMessage[]>;
	getMessagesAround(accountId: string, chatId: string, aroundId: string | null, aroundTime: string | null): Promise<borogove_ChatMessage[]>;
	getChatsUnreadDetails(accountId: string, chats: borogove_Chat[]): Promise<{chatId: string, message: borogove_ChatMessage, unreadCount: number}[]>;
	storeReaction(accountId: string, update: borogove_ReactionUpdate): Promise<borogove_ChatMessage | null>;
	updateMessageStatus(accountId: string, localId: string, status: borogove_MessageStatus, statusText: string | null): Promise<borogove_ChatMessage>;
	hasMedia(hashAlgorithm: string, hash: ArrayBuffer): Promise<boolean>;
	storeMedia(mime: string, bd: ArrayBuffer): Promise<boolean>;
	removeMedia(hashAlgorithm: string, hash: ArrayBuffer): void;
	storeCaps(caps: borogove_Caps): void;
	getCaps(ver: string): Promise<borogove_Caps>;
	storeLogin(login: string, clientId: string, displayName: string, token: string | null): void;
	getLogin(login: string): Promise<{clientId: string | null, displayName: string | null, fastCount: number, token: string | null}>;
	removeAccount(accountId: string, completely: boolean): void;
	listAccounts(): Promise<string[]>;
	storeStreamManagement(accountId: string, sm: ArrayBuffer | null): void;
	getStreamManagement(accountId: string): Promise<ArrayBuffer | null>;
	storeService(accountId: string, serviceId: string, name: string | null, node: string | null, caps: borogove_Caps): void;
	findServicesWithFeature(accountId: string, feature: string): Promise<{caps: borogove_Caps, name: string | null, node: string | null, serviceId: string}[]>;
}

export interface borogove_persistence_KeyValueStore {
	get(k: string): Promise<string | null>;
	set(k: string, v: string | null): Promise<boolean>;
}

export interface borogove_persistence_MediaStore {
	hasMedia(hashAlgorithm: string, hash: ArrayBuffer): Promise<boolean>;
	removeMedia(hashAlgorithm: string, hash: ArrayBuffer): void;
	storeMedia(mime: string, bytes: ArrayBuffer): Promise<boolean>;
}

